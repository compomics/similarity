/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package bookChapter.theoretical;

import cal.binBased.BinMSnSpectrum;
import cal.binBased.Calculate_BinSpectrum_Similarity;
import cal.methods.SimilarityMethods;
import preprocess.filter.noise.implementation.DivideAndNormalize;
import preprocess.filter.noise.implementation.DivideAndTopNFilter;
import preprocess.filter.noise.implementation.Filter;
import preprocess.filter.noise.implementation.TopNFiltering;
import preprocess.filter.precursor.RemovePrecursorRelatedPeaks;
import preprocess.filter.precursor.RemoveWindowAround;
import com.compomics.util.experiment.biology.Ion;
import com.compomics.util.experiment.biology.IonFactory;
import com.compomics.util.experiment.biology.Peptide;
import com.compomics.util.experiment.biology.ions.PeptideFragmentIon;
import com.compomics.util.experiment.massspectrometry.MSnSpectrum;
import com.compomics.util.experiment.massspectrometry.Peak;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import cal.cumulativeBinomialProbability.score.Andromeda_derived;

/**
 * This class scores a given spectrum against a peptide sequence according to either
 * Sequest-like or Andromeda-like scoring functions
 *
 * @author Sule
 */
public class Identify {

    private BinMSnSpectrum binnedSpectrum,
            binnedTheoreticalSpectrum;
    private MSnSpectrum spectrum;
    private Peptide peptide;
    private IonFactory fragmentFactory = IonFactory.getInstance();
    private ArrayList<Ion> theoretical_ions = new ArrayList<Ion>();
    private HashSet<TheoreticalPeak> theoretical_peaks = new HashSet<TheoreticalPeak>(); // containing peaks generated by given peptide sequence
    private double fragment_tolerance,
            score = Double.NEGATIVE_INFINITY,
            deltaCn = 0;
    private int totalScoredPeps = 0,
            correctionFactor = 0;
    private boolean isSequestLikeScore,// false: Andromeda-like true:Sequest-like
            isCorrectMatch, // true:correct match if either target/UPS, false:incorrect match if either decoy/Pfu
            isUniquePeptide = false; // true:a peptide is only from one protein, false: it exists on multiple proteins

    /**
     *
     * @param ms an MSnSpectrum object to compared
     * @param peptide a selected peptide entry from db within given precursor
     * tolerance
     * @param fragment_tolerance
     * @param isSequestLikeScore true:SEQUEST-like score, false:Andromeda-like
     * score
     * @param isCorrectMatch true:correct match if either target/UPS,
     * false:incorrect match if either decoy/Pfu
     * @param totalScoredPeps total number of peptides matched to a given ms
     * @param correctionFactor correction factor value for SEQUEST-like scoring
     * (to compute Xcorr)
     * @param hasAllPossCharge true: ions with all possible charges, false: only
     * up to doubly charged ions
     */
    public Identify(MSnSpectrum ms, Peptide peptide, double fragment_tolerance, boolean isSequestLikeScore, boolean isCorrectMatch, int totalScoredPeps, int correctionFactor, boolean hasAllPossCharge) {
        this.isSequestLikeScore = isSequestLikeScore;
        this.fragment_tolerance = fragment_tolerance;
        this.isCorrectMatch = isCorrectMatch;
        spectrum = ms;
        this.peptide = peptide;
        // get theoretical ions..
        HashMap<Integer, ArrayList<Ion>> product_ions_peptideA = fragmentFactory.getFragmentIons(peptide).get(0);
        // add all b- ions and y-ions with uniform intensity of 50
        theoretical_ions = product_ions_peptideA.get(PeptideFragmentIon.Y_ION);
        theoretical_ions.addAll(product_ions_peptideA.get(PeptideFragmentIon.B_ION));
        int prec = spectrum.getPrecursor().getPossibleCharges().get(0).value;
        if (hasAllPossCharge) {
            generate_theoretical_ions(prec);
        } else if (!hasAllPossCharge && prec >= 2) {
            generate_theoretical_ions(2);
        } else {
            generate_theoretical_ions(1);
        }
        this.totalScoredPeps = totalScoredPeps;
        this.correctionFactor = correctionFactor;
        score = match_and_score();
    }

    /**
     * This method generates theroetical ions up to given maxCharge
     *
     * @param maxCharge
     */
    private void generate_theoretical_ions(int maxCharge) {
        for (Ion t : theoretical_ions) {
            for (int i = maxCharge; i > 0; i--) {
                String name = t.getName() + "_" + i;
                TheoreticalPeak tp = new TheoreticalPeak(t.getTheoreticMz(i), 50, i, name);
                theoretical_peaks.add(tp);
            }
        }
    }

    public MSnSpectrum getSpectrum() {
        return spectrum;
    }

    public Peptide getPeptide() {
        return peptide;
    }

    public double getScore() {
        return score;
    }

    public boolean isIsSequestLikeScore() {
        return isSequestLikeScore;
    }

    public boolean isIsCorrectMatch() {
        return isCorrectMatch;
    }

    public double getDeltaCn() {
        return deltaCn;
    }

    public void setDeltaCn(double deltaCn) {
        this.deltaCn = deltaCn;
    }

    public int getTotalScoredPeps() {
        return totalScoredPeps;
    }

    public void setTotalScoredPeps(int totalScoredPeps) {
        this.totalScoredPeps = totalScoredPeps;
    }

    /**
     * This method calculates Andromeda-like scoring
     *
     * @return
     */
    private double calculateAndromedaLikeScore() {
        double massWindow = 100;
        ArrayList<Double> tmpScores = new ArrayList<Double>();
        // first remove precursor peak, any peak close to precursor ion within a fragment tolerance
        RemovePrecursorRelatedPeaks p = new RemovePrecursorRelatedPeaks(spectrum, fragment_tolerance);
        p.removePrecursor();
        // filter each experimental spectrum, varying topN as from 2 to 10. 
        for (int topN = 2; topN < 11; topN++) {
            Filter filterA = new DivideAndTopNFilter(spectrum, topN, massWindow);
            ArrayList<Peak> fP_spectrumA = filterA.getFilteredPeaks();
            int totalN = theoretical_peaks.size(),
                    n = findMatchedPeaks(theoretical_peaks, fP_spectrumA, fragment_tolerance);
            double probability = (double) topN / (double) massWindow;
            Andromeda_derived object = new Andromeda_derived(probability, totalN, n);
            double tmpScore = object.getScore();
            tmpScore += 0.0; // to make sure that score is not negative zero
            tmpScores.add(tmpScore);
        }
        // select the maximum score
        double finalScore = Collections.max(tmpScores);
        return finalScore;
    }

    /**
     * This method matches theoretical peaks against a filtered-experimental
     * peak-list
     *
     * @param theoretical_peaks a list of theoretical peaks from a given peptide
     * @param fP_spectrumA a list of experimental peaks on a filtered spectrum
     * @param fragment_tolerance a fragment tolerance
     *
     * @return the number of matched peaks
     */
    private int findMatchedPeaks(HashSet<TheoreticalPeak> theoretical_peaks, ArrayList<Peak> fP_spectrumA, double fragment_tolerance) {
        int matched = 0;
        // Select only a closest theoretical peak..
        for (Peak p : fP_spectrumA) {
            double mz = p.getMz();
            boolean isFound = false;
            for (TheoreticalPeak theoPeak : theoretical_peaks) {
                double tmpDiff = Math.abs(mz - theoPeak.getMz());
                if (tmpDiff <= fragment_tolerance) {
                    isFound = true;
                }
            }
            if (isFound) {
                matched++;
            }
        }
        return matched;
    }

    private double match_and_score() {
        if (isSequestLikeScore) {
            calculateSequestLikeScore();
        } else {
            score = calculateAndromedaLikeScore();
        }
        return score;
    }

    private void calculateSequestLikeScore() {
        // first remove a mz-window around precursor ion, with a window size of 10       
        RemoveWindowAround p = new RemoveWindowAround(spectrum, fragment_tolerance);
        p.removePrecursor();
        // then keep the top200 intense peaks
        TopNFiltering t = new TopNFiltering(200);
        spectrum = t.noiseFilter(spectrum);
        // now divide and normalize experimental spectrum
        int interval = 10,
                normalizeValue = 50;
        // JUST MAKING SURE THAT a filtered spectrum has enough peaks
        if (!spectrum.getPeakList().isEmpty()) {
            Filter filterA = new DivideAndNormalize(spectrum, interval, normalizeValue);
            ArrayList<Peak> fP_spectrumA = filterA.getFilteredPeaks();
            ArrayList<TheoreticalPeak> theoPeaks = new ArrayList<TheoreticalPeak>(theoretical_peaks);
            Collections.sort(theoPeaks, TheoreticalPeak.ASC_mz_order);
            // now convert to binExperimental spectrum
            double min_value = spectrum.getMinMz(),
                    max_value = spectrum.getMaxMz();
            if (theoPeaks.get(0).getMz() < min_value) {
                min_value = theoPeaks.get(0).getMz();
            }
            if (theoPeaks.get(theoPeaks.size() - 1).getMz() > max_value) {
                max_value = theoPeaks.get(theoPeaks.size() - 1).getMz();
            }
            int intensity_option = 0;
            //prepare binnedSpectrum 
            BinMSnSpectrum binnedSpectrum = new BinMSnSpectrum(fP_spectrumA, min_value, max_value, fragment_tolerance, intensity_option, correctionFactor), // experimental one is being shifted..
                    binnedTheoreticalSpectrum = new BinMSnSpectrum(new ArrayList<Peak>(theoretical_peaks), min_value, max_value, fragment_tolerance, intensity_option);
            // calculate sliding-dot-product
            Calculate_BinSpectrum_Similarity o = new Calculate_BinSpectrum_Similarity(binnedTheoreticalSpectrum, binnedSpectrum, SimilarityMethods.SLIDING_DOT_PRODUCT, fragment_tolerance);
            double sliding_dot_product = o.getScore();
            score = sliding_dot_product;
        }
    }

    @Override
    public int hashCode() {
        int hash = 7;
        hash = 53 * hash + (this.binnedSpectrum != null ? this.binnedSpectrum.hashCode() : 0);
        hash = 53 * hash + (this.binnedTheoreticalSpectrum != null ? this.binnedTheoreticalSpectrum.hashCode() : 0);
        hash = 53 * hash + (this.spectrum != null ? this.spectrum.hashCode() : 0);
        hash = 53 * hash + (this.peptide.getSequence() != null ? this.peptide.getSequence().hashCode() : 0);
        hash = 53 * hash + (this.fragmentFactory != null ? this.fragmentFactory.hashCode() : 0);
        hash = 53 * hash + (this.theoretical_ions != null ? this.theoretical_ions.hashCode() : 0);
        hash = 53 * hash + (this.theoretical_peaks != null ? this.theoretical_peaks.hashCode() : 0);
        hash = 53 * hash + (int) (Double.doubleToLongBits(this.fragment_tolerance) ^ (Double.doubleToLongBits(this.fragment_tolerance) >>> 32));
        hash = 53 * hash + (int) (Double.doubleToLongBits(this.score) ^ (Double.doubleToLongBits(this.score) >>> 32));
        hash = 53 * hash + (int) (Double.doubleToLongBits(this.deltaCn) ^ (Double.doubleToLongBits(this.deltaCn) >>> 32));
        hash = 53 * hash + this.totalScoredPeps;
        hash = 53 * hash + this.correctionFactor;
        hash = 53 * hash + (this.isSequestLikeScore ? 1 : 0);
        hash = 53 * hash + (this.isCorrectMatch ? 1 : 0);
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final Identify other = (Identify) obj;
        if (this.binnedSpectrum != other.binnedSpectrum && (this.binnedSpectrum == null || !this.binnedSpectrum.equals(other.binnedSpectrum))) {
            return false;
        }
        if (this.binnedTheoreticalSpectrum != other.binnedTheoreticalSpectrum && (this.binnedTheoreticalSpectrum == null || !this.binnedTheoreticalSpectrum.equals(other.binnedTheoreticalSpectrum))) {
            return false;
        }
        if (this.spectrum != other.spectrum && (this.spectrum == null || !this.spectrum.equals(other.spectrum))) {
            return false;
        }
        if (this.peptide != other.peptide && (this.peptide == null || !this.peptide.equals(other.peptide))) {
            return false;
        }
        if (this.fragmentFactory != other.fragmentFactory && (this.fragmentFactory == null || !this.fragmentFactory.equals(other.fragmentFactory))) {
            return false;
        }
        if (this.theoretical_ions != other.theoretical_ions && (this.theoretical_ions == null || !this.theoretical_ions.equals(other.theoretical_ions))) {
            return false;
        }
        if (this.theoretical_peaks != other.theoretical_peaks && (this.theoretical_peaks == null || !this.theoretical_peaks.equals(other.theoretical_peaks))) {
            return false;
        }
        if (Double.doubleToLongBits(this.fragment_tolerance) != Double.doubleToLongBits(other.fragment_tolerance)) {
            return false;
        }
        if (Double.doubleToLongBits(this.score) != Double.doubleToLongBits(other.score)) {
            return false;
        }
        if (Double.doubleToLongBits(this.deltaCn) != Double.doubleToLongBits(other.deltaCn)) {
            return false;
        }
        if (this.totalScoredPeps != other.totalScoredPeps) {
            return false;
        }
        if (this.correctionFactor != other.correctionFactor) {
            return false;
        }
        if (this.isSequestLikeScore != other.isSequestLikeScore) {
            return false;
        }
        if (this.isCorrectMatch != other.isCorrectMatch) {
            return false;
        }
        return true;
    }

    // put a method to compare Identify objects..
    public static final Comparator<Identify> ScoreDESC = new Comparator<Identify>() {
        @Override
        public int compare(Identify o1, Identify o2) {
            return o1.getScore() > o2.getScore() ? -1 : o1.getScore() == o2.getScore() ? 0 : 1;
        }
    };

    @Override
    public String toString() {
        return "Identify{" + "spectrum=" + spectrum.getSpectrumTitle() + ", peptide=" + peptide.getSequence() + ", score=" + score + ", deltaCn=" + deltaCn + ", totalScoredPeps=" + totalScoredPeps + ", isSequestLikeScore=" + isSequestLikeScore + '}';
    }

    /**
     * To sort CPeptideIon in a ascending mass order
     */
    public static final Comparator<Identify> ASC_score
            = new Comparator<Identify>() {
                @Override
                public int compare(Identify o1, Identify o2) {
                    return o1.getScore() < o2.getScore() ? -1 : o1.getScore() == o2.getScore() ? 0 : 1;
                }
            };
}
